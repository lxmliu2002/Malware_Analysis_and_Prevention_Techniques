# <center>**恶意代码分析与防治技术实验报告**</center>

## <center>R77</center>

## <center> **网络空间安全学院 信息安全专业**</center>

## <center> **2112492 刘修铭 1063**</center>

https://github.com/lxmliu2002/Malware_Analysis_and_Prevention_Techniques

# 一、实验目的

1. 了解 R77 的工作原理；
1. 进一步熟悉静态分析与动态分析的过程。



# 二、实验环境

为了保护本机免受恶意代码攻击，本次实验主体在虚拟机上完成，以下为相关环境：

1. 已关闭病毒防护的 Windows11
2. 在 VMware 上部署的 Windows XP 虚拟机
   * 在进行动态分析时，需对虚拟机做如下处理：
     * 对 VMware 进行快照，便于恢复到运行前的状态
     * 启动 ApateDNS，将 DNS Reply IP 设置为 127.0.0.1
     * 启动 Process Monitor，并按照实验要求设置过滤条件
     * 启动 Process Explorer
     * 启动 netcat：nc-l -p XXX
     * 启动 WireShark 抓取数据包



# 三、实验工具

1. 待分析病毒样本（解压缩于 XP 虚拟机）

2. 相关病毒分析工具，如 PETools、PEiD、Strings、OllyDbg、IDA 等

3. WinDbg 内核调试工具

4. Yara 检测引擎



# 四、实验过程

## （一）原理分析

首先使用 Srtings 打开 Install.exe 文件，查看其字符串。可以看到如 ole32.dll、 OLEAUT32.dll、psapi.dll 等 dll 文件的字符串，而上述字符串所对应的 dll 文件主要用于进程的监视与注入等相关操作，与 R77 的功能相吻合。









## （一）Lab 12-1

### 1. 程序分析

使用 Strings 打开文件，查看其字符串，可以看到 explorer.exe、lab12-01.dll 以及 psapi.dll 等，推测是恶意代码的一些目标文件。同时可以看到 Loadlibrary 等函数，推测恶意代码会使用这些函数进行攻击。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103102056.png" style="zoom:50%;" />

接下来使用 Dependency Walker 查看其导入导出函数，可以看到  CreateRemoteThread、WriteProcessMemory 以及 VirtualAllocEx 等函数，通常被恶意代码用来操作进程。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103102224.png" style="zoom:50%;" />

运行文件，可以看到其弹出消息框。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103102359.png" style="zoom:50%;" />

查看 Procomon，可以看到其捕获到了恶意代码的行为，可以看到其对 psapi.dll 进行了一些操作。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103102443.png" style="zoom:50%;" />

查看 Process explorer，可以看到 Lab12-01.dll 文件被加载到 explorer.exe 中。

<img src="./pic/WX20231103-141856@2x.png" style="zoom:50%;" />

使用 IDA 深入分析。可以看到，main 函数使用 LoadLibrary 以及 GetProcAddress 等函数将 psapi.dll 作为参数进行解析，并将结果保存在 dword_408714，dword_40870c，dword_408710 中。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103114905.png" style="zoom:50%;" />

继续分析，可以看到 dword_408710 被调用，用于获取系统中进程对象的 PID，并返回一个数组。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103115022.png" style="zoom:50%;" />

切换视图，可以看到其为一个循环结构，前面提到的数组被用于迭代进程列表。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103115048.png" style="zoom:50%;" />

查看循环结构体，可以看到每次都会调用 sub_401000 函数。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103115105.png" style="zoom:50%;" />

步入该函数进行分析。可以看到其首先调用 OpenProcess 打开进程，接着使用  MyEnumProcessModule 函数获取该进程的全部模块。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103115129.png" style="zoom:50%;" />

继续分析，可以看到其调用 GetModuleBaseNameA 将 PID 获取为进程名。而 call__strnicmp 则将获得的字符串与 explorer.exe 进行比较。即该部分用于查找 explorer.exe 进程。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103115151.png" style="zoom: 50%;" />

继续分析，可以看到其调用 OpenProcess 打开其句柄。接着使用 push 104h 指令将 0x104 字节压栈，调用 VirtualAllocEx 进行内存分配，接着将 lpBaseAddress 和 hProcess 作为参数调用 WriteProcessMemory，向 explorer.exe 中写入 lpBufer 中的数据。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103115326.png" style="zoom:50%;" />

接着查看 lpBufer，可以看到是调用 GetCurrentDirectoryA 获取当前路径，并与 Lab12-01.dll 拼接，因此可以得知 lpBuffer 的内容就是 Lab12-01.dll 的路径。即将 Lab12-01.dll 写入到了explorer.exe 中，与前面现象相匹配。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103115411.png" style="zoom:50%;" />

返回继续分析，可以看到其先调用 WriteProcessMemory，写入之后则会调用 GetModuleHandleA 、GetProcAddress 用于获取 kernerl32.dll 中的LoadLibrary 的地址返回的地址，并将其赋给 lpStartAddress，接着将其作为参数调用 CreateRemoteThread 函数。基于此，explorer.exe 会使用 Lab12-01.dll 作为参数调用 LoadLibraryA。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103115528.png" style="zoom:50%;" />

接着使用 IDA 分析 dll 文件。可以看到其首先调用 CreateThread 函数创建线程。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103115759.png" style="zoom:50%;" />

下面步入分析其调用的 sub_10001030 函数。切换视图可以看到其为一个循环结构。循环体中同样调用 CreateThread 函数创建线程。接着以 60000 作为参数调用 Sleep 函数，即每次运行时间间隔一分钟。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103115821.png" style="zoom:40%;" />

步入查看 StartAddress 函数，可以看到其调用 MessageBoxA 函数创建消息提示框显示 Press OK to reboot，这与前面分析相吻合。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103115904.png" style="zoom:50%;" />

返回分析，可以看到 var_18 被赋初值为 0，运行后被被拼接到字符串后，每次循环自增。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231103115943.png" style="zoom:50%;" />

#### 



## （二）yara 规则

基于上述分析，编写得到如下 yara 规则：

```yara
rule lab1201exe{
strings:
	$dll1 = "Lab12-01.dll"
	$string1 = "GetModuleBaseNameA"
    $dll2 = "psapi.dll"
    $string2 = "EnumProcessModules"
condition:
    filesize < 200KB and uint16(0) == 0x5A4D and uint16(uint16(0x3C)) == 0x00004550 and all of them
}
rule lab1202exe{
strings:
    $reg1 = "AAAqAAApAAAsAAArAAAuAAAtAAAwAAAvAAAyAAAxAAA"
	$dll1 = "spoolvxx32.dll"
	$exe1 = "svchost.exe"
    $string = "NtUnmapViewOfSection"
condition:
    filesize < 200KB and uint16(0) == 0x5A4D and uint16(uint16(0x3C)) == 0x00004550 and all of them
}
rule lab1203exe{
strings:
	$log = "practicalmalwareanalysis.logl"
	$func = "VirtualAlloc"
    $string1 = "TerminateProcess"
    $string2 = "[Window:"
condition:
    filesize < 200KB and uint16(0) == 0x5A4D and uint16(uint16(0x3C)) == 0x00004550 and all of them
}
rule lab1204exe{
strings:
    $log = "http://www.practicalmalwareanalysis.com//updater.exe"
	$exe1 = "wupdmgrd.exe"
	$exe2  = "winup.exe"
    $string1 = "<SHIFT>"
    $string2 = "%s%s"
condition:
    filesize < 200KB and uint16(0) == 0x5A4D and uint16(uint16(0x3C)) == 0x00004550 and all of them
}
```

下面是运行结果图。



下面测试其运行效率，得到如下运行结果。



## （三）IDA Python 脚本编写

遍历所有函数，排除库函数或简单跳转函数，当反汇编的助记符为 call 或者 jmp 且操作数为寄存器类型时，输出该行反汇编指令。

```python
import idautils
ea=idc.ScreenEA()
funcName=idc.GetFunctionName(ea)
func=idaapi.get_func(ea)
print("FuncName:%s"%funcName) # 获取函数名
print "Start:0x%x,End:0x%x" % (func.startEA,func.endEA) # 获取函数开始地址和结束地址
# 分析函数属性 
flags = idc.GetFunctionFlags(ea)
if flags&FUNC_NORET:
    print "FUNC_NORET"
if flags & FUNC_FAR:
    print "FUNC_FAR"
if flags & FUNC_STATIC:
    print "FUNC_STATIC"
if flags & FUNC_FRAME:
    print "FUNC_FRAME"
if flags & FUNC_USERFAR:
    print "FUNC_USERFAR"
if flags & FUNC_HIDDEN:
    print "FUNC_HIDDEN"
if flags & FUNC_THUNK:
    print "FUNC_THUNK"
if not(flags & FUNC_LIB or flags & FUNC_THUNK):# 获取当前函数中call或者jmp的指令
    dism_addr = list(idautils.FuncItems(ea))
    for line in dism_addr:
        m = idc.GetMnem(line)
        if m == "call" or m == "jmp":
            print "0x%x %s" % (line,idc.GetDisasm(line))
```

得到如下结果：





# 五、实验结论及心得

1. 熟悉了静态与动态结合分析病毒的方法；
1. 了解了 R77 的工作原理，复习了隐蔽启动的相关内容；
1. 更加熟悉了 yara 规则的编写。
