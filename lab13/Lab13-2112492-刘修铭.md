# <center>**恶意代码分析与防治技术实验报告**</center>

## <center>Lab13</center>

## <center> **网络空间安全学院 信息安全专业**</center>

## <center> **2112492 刘修铭 1063**</center>

https://github.com/lxmliu2002/Malware_Analysis_and_Prevention_Techniques



[恶意代码分析实战 数据加密 lab 13-1 13-2 13-3 常见base64 aes这些都是比较好解密的 实在不行还可以immunity dbg打断点写py脚本解密 - bonelee - 博客园 (cnblogs.com)](https://www.cnblogs.com/bonelee/p/16757408.html)

[恶意代码分析实战 第十三章 实验部分 - 简书 (jianshu.com)](https://www.jianshu.com/p/391fae18b1f0)

[恶意代码分析实战13-01_Elwood Ying的博客-CSDN博客](https://blog.csdn.net/yalecaltech/article/details/117934676)

[恶意代码分析实战13-02_恶意代码分析实战lab13-2-CSDN博客](https://blog.csdn.net/yalecaltech/article/details/117934602)

[恶意代码分析实战13-02_恶意代码分析实战lab13-2-CSDN博客](https://blog.csdn.net/yalecaltech/article/details/117934602)







# 一、实验目的

1. 了解数据加密；
1. 进一步熟悉静态分析与动态分析的过程。



# 二、实验环境

为了保护本机免受恶意代码攻击，本次实验主体在虚拟机上完成，以下为相关环境：

1. 已关闭病毒防护的 Windows11
2. 在 VMware 上部署的 Windows XP 虚拟机
   * 在进行动态分析时，需对虚拟机做如下处理：
     * 对 VMware 进行快照，便于恢复到运行前的状态
     * 启动 ApateDNS，将 DNS Reply IP 设置为 127.0.0.1
     * 启动 Process Monitor，并按照实验要求设置过滤条件
     * 启动 Process Explorer
     * 启动 netcat：nc-l -p XXX
     * 启动 WireShark 抓取数据包



# 三、实验工具

1. 待分析病毒样本（解压缩于 XP 虚拟机）

2. 相关病毒分析工具，如 PETools、PEiD、Strings、OllyDbg、IDA等

3. WinDbg 内核调试工具

4. Yara 检测引擎



# 四、实验过程

## （一）Lab 13-1

### 1. 程序分析



### 2. 问题解答

#### （1）比较恶意代码中的字符串（字符串命令的输出）与动态分析提供的有用信息，基于这些比较，哪些元素可能被加密？



#### （2）使用 IDA Pro 搜索恶意代码中字符串 ’xor’，以此来查找潜在的加密，你发现了哪些加密类型？



#### （3）恶意代码使用什么密钥加密，加密了什么内容？



#### （4）使用静态工具 FindCrypt2、Krypto ANALyzer（KANAL）以及 IDA 熵插件识别一些其他类型的加密机制，你发现了什么？



#### （5）什么类型的加密被恶意代码用来发送部分网络流量？



#### （6）Base64 编码函数在反汇编的何处？



#### （7）恶意代码发送的 Base64 加密数据的最大长度是什么？加密了什么内容？



#### （8）恶意代码中，你是否在 Base64 加密数据中看到了填充字符（= 或者 ==）？



#### （9）这个恶意代码做了什么？







## （二）Lab 13-2

### 1. 程序分析



### 2. 问题解答

#### （1）使用动态分析，确定恶意代码创建了什么？



#### （2）使用静态分析技术，例如 xor 指令搜索、FidCrypt2、KANAL 以及 IDA 熵插件，查找潜在的加密，你发现了什么？



#### （3）基于问题 1 的回答，哪些导入函数将是寻找加密函数比较好的一个证据？



#### （4）加密函数在反汇编的何处？



#### （5）从加密函数追溯原始的加密内容，原始加密内容是什么？



#### （6）你是否能够找到加密算法？如果没有，你如何解密这些内容？



#### （7）使用解密工具，你是否能够恢复加密文件中的一个文件到原始文件？






## （三）Lab 13-3

### 1. 程序分析



### 2. 问题解答

#### （1）比较恶意代码的输出字符串和动态分析提供的信息，通过这些比较，你发现哪些元素可能被加密？



#### （2）使用静态分析搜索字符串 xor 来查找潜在的加密。通过这种方法，你发现什么类型的加密？



#### （3）使用静态工具，如 FindCrypt2、KANAL 以及 IDA 熵插件识别一些其他类型的加密机制。发现的结果与搜索字符 XOR 结果比较如何？



#### （4）恶意代码使用哪两种加密技术？



#### （5）对于每一种加密技术，它们的密钥是什么？



#### （6）对于加密算法，它的密钥足够可靠吗？另外你必须知道什么？



#### （7）恶意代码做了什么？



#### （8）构造代码来解密动态分析过程中生成的一些内容，解密后的内容是什么？








## （四）yara规则

基于上述分析，编写得到如下yara规则：

```yara

```

下面是运行结果图。



下面测试其运行效率，得到如下运行结果。





## （五）IDA Python脚本编写

遍历所有函数，排除库函数或简单跳转函数，当反汇编的助记符为call或者jmp且操作数为寄存器类型时，输出该行反汇编指令。

```python
import idautils
ea=idc.ScreenEA()
funcName=idc.GetFunctionName(ea)
func=idaapi.get_func(ea)
print("FuncName:%s"%funcName) # 获取函数名
print "Start:0x%x,End:0x%x" % (func.startEA,func.endEA) # 获取函数开始地址和结束地址
# 分析函数属性 
flags = idc.GetFunctionFlags(ea)
if flags&FUNC_NORET:
    print "FUNC_NORET"
if flags & FUNC_FAR:
    print "FUNC_FAR"
if flags & FUNC_STATIC:
    print "FUNC_STATIC"
if flags & FUNC_FRAME:
    print "FUNC_FRAME"
if flags & FUNC_USERFAR:
    print "FUNC_USERFAR"
if flags & FUNC_HIDDEN:
    print "FUNC_HIDDEN"
if flags & FUNC_THUNK:
    print "FUNC_THUNK"
if not(flags & FUNC_LIB or flags & FUNC_THUNK):# 获取当前函数中call或者jmp的指令
    dism_addr = list(idautils.FuncItems(ea))
    for line in dism_addr:
        m = idc.GetMnem(line)
        if m == "call" or m == "jmp":
            print "0x%x %s" % (line,idc.GetDisasm(line))
```

得到如下结果：





# 五、实验结论及心得

1. 熟悉了静态与动态结合分析病毒的方法；
1. 了解了数据加密相关内容；
1. 更加熟悉了yara规则的编写。
