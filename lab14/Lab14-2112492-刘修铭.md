# <center>**恶意代码分析与防治技术实验报告**</center>

## <center>Lab14</center>

## <center> **网络空间安全学院 信息安全专业**</center>

## <center> **2112492 刘修铭 1063**</center>

https://github.com/lxmliu2002/Malware_Analysis_and_Prevention_Techniques



[《恶意代码分析实战》实验——Labs-14_长白山下大绵羊的博客-CSDN博客](https://blog.csdn.net/weixin_39561364/article/details/115938526)

[恶意代码分析实战 第十四章课后实验_labs14-03-CSDN博客](https://blog.csdn.net/Stronger_99/article/details/89495981)

[恶意代码分析实战14-1_bytes文件_Elwood Ying的博客-CSDN博客](https://blog.csdn.net/yalecaltech/article/details/117399661)

[恶意代码分析实战14-02_恶意代码分析lab14-02_Elwood Ying的博客-CSDN博客](https://blog.csdn.net/yalecaltech/article/details/117934748?ops_request_misc=%7B%22request%5Fid%22%3A%22169891611816800192233777%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=169891611816800192233777&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-117934748-null-null.nonecase&utm_term=恶意代码分析实战14-2&spm=1018.2226.3001.4450)

[恶意代码分析实战14-03_恶意代码分析实战实验14-3-CSDN博客](https://blog.csdn.net/yalecaltech/article/details/117934828)



# 一、实验目的

1. 了解恶意代码的网络特征；
1. 进一步熟悉静态分析与动态分析的过程。



# 二、实验环境

为了保护本机免受恶意代码攻击，本次实验主体在虚拟机上完成，以下为相关环境：

1. 已关闭病毒防护的 Windows11
2. 在 VMware 上部署的 Windows XP 虚拟机
   * 在进行动态分析时，需对虚拟机做如下处理：
     * 对 VMware 进行快照，便于恢复到运行前的状态
     * 启动 ApateDNS，将 DNS Reply IP 设置为 127.0.0.1
     * 启动 Process Monitor，并按照实验要求设置过滤条件
     * 启动 Process Explorer
     * 启动 netcat：nc-l -p XXX
     * 启动 WireShark 抓取数据包



# 三、实验工具

1. 待分析病毒样本（解压缩于 XP 虚拟机）

2. 相关病毒分析工具，如 PETools、PEiD、Strings、OllyDbg、IDA等

3. WinDbg 内核调试工具

4. Yara 检测引擎



# 四、实验过程

## （一）Lab 14-1

### 1. 程序分析



### 2. 问题解答

#### （1）恶意代码使用了哪些网络库？它们的优势是什么？



#### （2）用于构建网络信令的信息源元素是什么，什么样的条件会引起信令的改变？



#### （3）为什么攻击者可能对嵌入在网络信令中的信息感兴趣？



#### （4）恶意代码是否使用了标准的 Base64 编码？如果不是，编码是如何不寻常的？



#### （5）恶意代码的主要目的是什么？



#### （6）使用网络特征可能有效探测到恶意代码通信中的什么元素？



#### （7）分析者尝试为这个恶意代码开发一个特征时，可能会犯什么错误？



#### （8）哪些特征集可能检测到这个恶意代码（以及新的变种）？









## （二）Lab 14-2

### 1. 程序分析



### 2. 问题解答

#### （1）恶意代码编写时直接使用 IP 地址的好处和坏处各是什么？



#### （2）这个恶意代码使用哪些网络库？使用这些库的好处和坏处是什么？



#### （3）恶意代码信令中 URL 的信息源是什么？这个信息源提供了哪些优势？



#### （4）恶意代码利用了 HTTP 协议的哪个方面，来完成它的目的？



#### （5）在恶意代码的初始信令中传输的是哪种信息？



#### （6）这个恶意代码通信信道的设计存在什么缺点？



#### （7）恶意代码的编码方案是标准的吗？



#### （8）通信是如何被终止的？



#### （9）这个恶意代码的目的是什么？在攻击者的工具中，它可能会起到什么作用？



## （三）Lab 14-3

### 1. 程序分析



### 2. 问题解答

#### （1）在初始信令中硬编码元素是什么？什么元素能够用于创建一个好的网络特征？



#### （2）初始信令中的什么元素可能不利于可持久使用的网络特征？



#### （3）恶意代码是如何获得命令的？本章中的什么例子用了类似的方法？这种技术的优点是什么？



#### （4）当恶意代码接收到输入时，在输入上执行什么检查可以决定它是否是一个有用的命令？攻击者如何隐藏恶意代码正在寻找的命令列表？



#### （5）什么类型的编码用于命令参数？它与 Base64 编码有什么不同?它提供的优点和缺点各是什么？



#### （6）这个恶意代码会接收哪些命令？



#### （7）这个恶意代码的目的是什么？



#### （8）本章介绍了用独立的特征，来针对不同位置代码的想法，以增加网络特征的鲁棒性。那么在这个恶意代码中，可以针对哪些区段的代码，或是配置文件，来提取网络特征？



#### （9）什么样的网络特征集应该被用于检测恶意代码？




## （四）yara规则

基于上述分析，编写得到如下yara规则：

```yara

```

下面是运行结果图。



下面测试其运行效率，得到如下运行结果。





## （五）IDA Python脚本编写

遍历所有函数，排除库函数或简单跳转函数，当反汇编的助记符为call或者jmp且操作数为寄存器类型时，输出该行反汇编指令。

```python
import idautils
ea=idc.ScreenEA()
funcName=idc.GetFunctionName(ea)
func=idaapi.get_func(ea)
print("FuncName:%s"%funcName) # 获取函数名
print "Start:0x%x,End:0x%x" % (func.startEA,func.endEA) # 获取函数开始地址和结束地址
# 分析函数属性 
flags = idc.GetFunctionFlags(ea)
if flags&FUNC_NORET:
    print "FUNC_NORET"
if flags & FUNC_FAR:
    print "FUNC_FAR"
if flags & FUNC_STATIC:
    print "FUNC_STATIC"
if flags & FUNC_FRAME:
    print "FUNC_FRAME"
if flags & FUNC_USERFAR:
    print "FUNC_USERFAR"
if flags & FUNC_HIDDEN:
    print "FUNC_HIDDEN"
if flags & FUNC_THUNK:
    print "FUNC_THUNK"
if not(flags & FUNC_LIB or flags & FUNC_THUNK):# 获取当前函数中call或者jmp的指令
    dism_addr = list(idautils.FuncItems(ea))
    for line in dism_addr:
        m = idc.GetMnem(line)
        if m == "call" or m == "jmp":
            print "0x%x %s" % (line,idc.GetDisasm(line))
```

得到如下结果：





# 五、实验结论及心得

1. 熟悉了静态与动态结合分析病毒的方法；
1. 了解了恶意代码网络特征的相关内容；
1. 更加熟悉了yara规则的编写。
